# Intro to GDB

GDB is a powerfull tool to debug your c code when things got complicated, it is
really powerfull and the aim of this tutorial is to walk over my personal
learnings ([presentation](https://drive.google.com/open?id=1aaExMhw1xqWeX8uiUNKiuDD1ZWlIcm5v3wWCn1rlc-w)):

## Segfault

Lets imagine we have the following code:

```C
#include <stdio.h>

int main() {
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
	return 0;
}

```

if we compile and run, we will get:

```shell
Segmentation fault (core dumped)
```

How to debug this , very simple:

* compile with the -g option:

```shell
    gcc -g segfaul.c -o segfault
```

Then run the binary with gdb:

```shell
gdb ./segfault
```

Be aware that the symbols are loaded:

```gdb
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./segfault...done.
```

Then just run:

```gdb
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';
```

Which makes sence on the line of code with the error

## Saving the error in a coredump

After the error, occurs:
```gdb
(gdb) generate-core-file
Saved corefile core.22663
```

This file can be used latter for future debug:

```gdb
gdb ./segfault core.22663

[...]
Reading symbols from ./segfault...done.
[New LWP 22663]
Core was generated by `/home/vmrod/hobbies/c_programing_exercises/gdb/segfault'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';

```

This is usefull sometimes when we dont want to re run the test failure


## Backtrace

A backtrace is a summary of how your program got where it is. It shows one line
per frame, for many frames, starting with the currently executing frame (frame
zero), followed by its caller (frame one), and on up the stack.

```gdb
(gdb) bt
#0  0x0000555555554611 in main () at segfaul.c:8
(gdb) bt full
#0  0x0000555555554611 in main () at segfaul.c:8
        str = 0x5555555546a4 "GfG"
```

Even if we have nested functions:


```C
#include <stdio.h>

void foo(){
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
}

int main() {
    foo();
	return 0;
}
```

gdb backtrace is able to do the debug:

```gdb
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in foo () at segfaul.c:8
8		*(str+1) = 'n';
(gdb) bt
#0  0x0000555555554611 in foo () at segfaul.c:8
#1  0x0000555555554625 in main () at segfaul.c:11
```

## info registers

```gdb
(gdb) info registers

rip            0x555555554611	0x555555554611 <foo+23>
```

As we can see the addrs: 0x555555554611 match with the one reported by
segfault:

```gdb
0x0000555555554611 in foo () at segfaul.c:8
```

## More complete debug view

GDB provides a nice view of the code while we walk through the source:

Example code:

```C
int main() {
    int count=0;
    for (int i=0;i<10;i++){
        count = count +10;
    }
	return 0;
}
```

Compile and run the debug as:

```gdb
gcc -g loop.c -o loop
gdb ./loop -tui
```
This will present a really nice view of the code at the time we set brakpoints
and are able to print each variable:

```gdb
b main  \\ breakpoint at main
run     \\ run the code
n       \\ next
p count \\

(gdb) p count
$3 = 10
(gdb) p count
$4 = 10
(gdb) n
(gdb) n
(gdb) n
(gdb) p count
$5 = 30
```

To clear the breakpoints:

* clear:
Delete any breakpoints at the next instruction to be executed in the selected
stack frame (see section Selecting a frame). When the innermost frame is
selected, this is a good way to delete a breakpoint where your program just
stopped.

* clear function
* clear filename:function
Delete any breakpoints set at entry to the function function.


For example:

```gdb
(gdb) clear main
Deleted breakpoint 1
```

And we can now set a breakpoint with condition:

```gdb
(gdb) break 5 if count=80
Breakpoint 1 at 0x60e: file loop.c, line 5.
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/loop

Breakpoint 1, main () at loop.c:5
(gdb) p count
$1 = 80

```

## Debuging forks

Lets imagine that we have a fork() inside aour code and
we want to debug the inner loop that the child process has:

```C
int main() {
    int var = 0;
	pid_t pid;

	printf("Main Process PID = %d\n", getpid());
	/* fork a child process */
	pid = fork();

	if (pid < 0) {
		/* error occurred */
		fprintf(stderr, "Fork Failed");
		exit (-1) ;
	}
    else if (pid == 0) {
		/* child process */
	    printf("[child] Parent PID = %d\n", getppid());
		printf("[child] Current PID = %d\n", getpid());
        for(int i = 0;i<10;i++){
            var = var +10;
        }
        printf("[child] var = %d\n",var);
	}
	else {
		/* parent process */
		/* parent will wait for the child to complete */
		wait(NULL);
		printf("Child Complete\n");
	}

    printf("var = %d\n",var);
}
```

We set a breakpoint at main:

```gdb
(gdb) b main
```

Now here comes the secret, by default, when a program forks, gdb will continue
to debug the parent process and the child process will run unimpeded.

If you want to follow the child process instead of the parent process, use the
command set follow-fork-mode.

* set follow-fork-mode mode :
    * Set the debugger response to a program call of fork or vfork. A call to
    fork or vfork creates a new process. The mode argument can be:
        * parent The original process is debugged after a fork. The child
          process runs unimpeded. This is the default.
        * child The new process is debugged after a fork. The parent process
          runs unimpeded.

```gdb
(gdb) set follow-fork-mode child
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/simple_fork

Breakpoint 1, main () at simple_fork.c:10
10	    int var = 0;
(gdb) n
13		printf("Main Process PID = %d\n", getpid());
(gdb) n
Main Process PID = 24237
15		pid = fork();
(gdb) n
[New process 24241]
[Switching to process 24241]
main () at simple_fork.c:17
17		if (pid < 0) {
(gdb) n
22	    else if (pid == 0) {
(gdb) n
24		    printf("[child] Parent PID = %d\n", getppid());
(gdb) n
[child] Parent PID = 24237
25			printf("[child] Current PID = %d\n", getpid());
(gdb) n
[child] Current PID = 24241
26	        for(int i = 0;i<10;i++){
(gdb) n
27	            var = var +10;
(gdb) n
26	        for(int i = 0;i<10;i++){
(gdb) n
27	            var = var +10;
(gdb) p var
$1 = 10
```

On Linux, if you want to debug both the parent and child processes, use the
command set detach-on-fork.

```
set detach-on-fork mode
```

Tells gdb whether to detach one of the processes after a fork, or retain
debugger control over them both.

* on: The child process (or parent process, depending on the value of
follow-fork-mode) will be detached and allowed to run independently. This is
the default.

* off: Both processes will be held under the control of GDB. One process
(child or parent, depending on the value of follow-fork-mode) is debugged as
usual, while the other is held suspended.

## Debug in an exec

If you ask to debug a child process and a vfork is followed by an exec, GDB
executes the new target up to the first breakpoint in the new target. If you
have a breakpoint set on main in your original program, the breakpoint will
also be set on the child processâ€™s main.

On some systems, when a child process is spawned by vfork, you cannot debug the
child or parent until an exec call completes.

If you issue a run command to GDB after an exec call executes, the new target
restarts. To restart the parent process, use the file command with the parent
executable name as its argument. By default, after an exec call executes, GDB
discards the symbols of the previous executable image. You can change this
behaviour with the set follow-exec-mode command.

```
set follow-exec-mode mode
```

Set debugger response to a program call of exec. An exec call replaces the
program image of a process.

follow-exec-mode can be:

* new: GDB creates a new inferior and rebinds the process to this new inferior.
The program the process was running before the exec call can be restarted
afterwards by restarting the original inferior


* same : GDB keeps the process bound to the same inferior. The new executable
image replaces the previous executable loaded in the inferior. Restarting the
inferior after the exec call, with e.g., the run command, restarts the
executable the process was running after the exec call. This is the default
mode.


You can use the catch command to make GDB stop whenever a fork, vfork, or exec
call is made. There is a
[list](https://sourceware.org/gdb/onlinedocs/gdb/Set-Catchpoints.html) of
events of what we can catch

```
(gdb) catch fork
Catchpoint 2 (fork)
```

```
(gdb) n

Catchpoint 2 (forked process 901721), 0x00007ffff7e804d2 in fork () from /usr/lib64/haswell/libc.so.6
(gdb) nint 1, main () at simple_fork.c:9
Single stepping until exit from function fork,
which has no line number information.
[Attaching after process 901630 fork to child process 901721]
[New inferior 3 (process 901721)]
[Detaching after fork from parent process 901630]
[Inferior 2 (process 901630) detached]
0x00007ffff7e2f660 in ?? () from /usr/lib64/haswell/libc.so.6
```

* TODO

	* Debug a thread
	* Debug in multiple cores
	* Debug shared libraries

[1] https://www-zeuthen.desy.de/unix/unixguide/infohtml/gdb/Forks.html
