# Intro to GDB

GDB is a powerfull tool to debug your c code when things got complicated, it is
really powerfull and the aim of this tutorial is to walk over my personal
learnings:

## Segfault

Lets imagine we have the following code:

```C
#include <stdio.h>

int main() {
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
	return 0;
}

```

if we compile and run, we will get:

```shell
Segmentation fault (core dumped)
```

How to debug this , very simple:

* compile with the -g option:

```shell
    gcc -g segfaul.c -o segfault
```

Then run the binary with gdb:

```shell
gdb ./segfault
```

Be aware that the symbols are loaded:

```gdb
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./segfault...done.
```

Then just run:

```gdb
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';
```

Which makes sence on the line of code with the error

## Saving the error in a coredump

After the error, occurs:
```gdb
(gdb) generate-core-file
Saved corefile core.22663
```

This file can be used latter for future debug:

```gdb
gdb ./segfault core.22663

[...]
Reading symbols from ./segfault...done.
[New LWP 22663]
Core was generated by `/home/vmrod/hobbies/c_programing_exercises/gdb/segfault'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';

```

This is usefull sometimes when we dont want to re run the test failure


## Backtrace

A backtrace is a summary of how your program got where it is. It shows one line
per frame, for many frames, starting with the currently executing frame (frame
zero), followed by its caller (frame one), and on up the stack.

```gdb
(gdb) bt
#0  0x0000555555554611 in main () at segfaul.c:8
(gdb) bt full
#0  0x0000555555554611 in main () at segfaul.c:8
        str = 0x5555555546a4 "GfG"
```

Even if we have nested functions:


```C
#include <stdio.h>

void foo(){
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
}

int main() {
    foo();
	return 0;
}
```

gdb backtrace is able to do the debug:

```gdb
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in foo () at segfaul.c:8
8		*(str+1) = 'n';
(gdb) bt
#0  0x0000555555554611 in foo () at segfaul.c:8
#1  0x0000555555554625 in main () at segfaul.c:11
```

## info registers

```gdb
(gdb) info registers

rip            0x555555554611	0x555555554611 <foo+23>
```

As we can see the addrs: 0x555555554611 match with the one reported by
segfault:

```gdb
0x0000555555554611 in foo () at segfaul.c:8
```

## More complete debug view

GDB provides a nice view of the code while we walk through the source:

Example code:

```C
int main() {
    int count=0;
    for (int i=0;i<10;i++){
        count = count +10;
    }
	return 0;
}
```

Compile and run the debug as:

```gdb
gcc -g loop.c -o loop
gdb ./loop -tui
```
This will present a really nice view of the code at the time we set brakpoints
and are able to print each variable:

```gdb
b main  \\ breakpoint at main
run     \\ run the code
n       \\ next
p count \\

(gdb) p count
$3 = 10
(gdb) p count
$4 = 10
(gdb) n
(gdb) n
(gdb) n
(gdb) p count
$5 = 30
```

To clear the breakpoints:

* clear:
Delete any breakpoints at the next instruction to be executed in the selected
stack frame (see section Selecting a frame). When the innermost frame is
selected, this is a good way to delete a breakpoint where your program just
stopped.

* clear function
* clear filename:function
Delete any breakpoints set at entry to the function function.


For example:

```gdb
(gdb) clear main
Deleted breakpoint 1
```

And we can now set a breakpoint with condition:

```gdb
(gdb) break 5 if count=80
Breakpoint 1 at 0x60e: file loop.c, line 5.
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/loop

Breakpoint 1, main () at loop.c:5
(gdb) p count
$1 = 80

```

## Debuging forks

Lets imagine that we have a fork() inside aour code and
we want to debug the inner loop that the child process has:

```C
int main() {
    int var = 0;
	pid_t pid;

	printf("Main Process PID = %d\n", getpid());
	/* fork a child process */
	pid = fork();

	if (pid < 0) {
		/* error occurred */
		fprintf(stderr, "Fork Failed");
		exit (-1) ;
	}
    else if (pid == 0) {
		/* child process */
	    printf("[child] Parent PID = %d\n", getppid());
		printf("[child] Current PID = %d\n", getpid());
        for(int i = 0;i<10;i++){
            var = var +10;
        }
        printf("[child] var = %d\n",var);
	}
	else {
		/* parent process */
		/* parent will wait for the child to complete */
		wait(NULL);
		printf("Child Complete\n");
	}

    printf("var = %d\n",var);
}
```

We set a breakpoint at main:

```gdb
(gdb) b main
```

Now here comes the secret, by default, when a program forks, gdb will continue
to debug the parent process and the child process will run unimpeded.

If you want to follow the child process instead of the parent process, use the
command set follow-fork-mode.

* set follow-fork-mode mode :
    * Set the debugger response to a program call of fork or vfork. A call to
    fork or vfork creates a new process. The mode argument can be:
        * parent The original process is debugged after a fork. The child
          process runs unimpeded. This is the default.
        * child The new process is debugged after a fork. The parent process
          runs unimpeded.

```gdb
(gdb) set follow-fork-mode child
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/simple_fork

Breakpoint 1, main () at simple_fork.c:10
10	    int var = 0;
(gdb) n
13		printf("Main Process PID = %d\n", getpid());
(gdb) n
Main Process PID = 24237
15		pid = fork();
(gdb) n
[New process 24241]
[Switching to process 24241]
main () at simple_fork.c:17
17		if (pid < 0) {
(gdb) n
22	    else if (pid == 0) {
(gdb) n
24		    printf("[child] Parent PID = %d\n", getppid());
(gdb) n
[child] Parent PID = 24237
25			printf("[child] Current PID = %d\n", getpid());
(gdb) n
[child] Current PID = 24241
26	        for(int i = 0;i<10;i++){
(gdb) n
27	            var = var +10;
(gdb) n
26	        for(int i = 0;i<10;i++){
(gdb) n
27	            var = var +10;
(gdb) p var
$1 = 10
```

* TODO

** Debug in an exec
** Debug a thread
** Debug in multiple cores
** Debug shared libraries

[1] https://www-zeuthen.desy.de/unix/unixguide/infohtml/gdb/Forks.html
