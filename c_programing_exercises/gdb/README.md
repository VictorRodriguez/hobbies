# Intro to GDB

GDB is a powerfull tool to debug your c code when things got complicated, it is
really powerfull and the aim of this tutorial is to walk over my personal
learnings:

## Segfault

Lets imagine we have the following code:

```
#include <stdio.h>

int main() {
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
	return 0;
}

```

if we compile and run, we will get:

```
Segmentation fault (core dumped)
```

How to debug this , very simple:

* compile with the -g option:

```
    gcc -g segfaul.c -o segfault
```

Then run the binary with gdb:

```
gdb ./segfault
```

Be aware that the symbols are loaded:

```
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./segfault...done.
```

Then just run:

```
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';
```

Which makes sence on the line of code with the error

## Saving the error in a coredump

After the error, occurs:
```
(gdb) generate-core-file
Saved corefile core.22663
```

This file can be used latter for future debug:

```
gdb ./segfault core.22663

[...]
Reading symbols from ./segfault...done.
[New LWP 22663]
Core was generated by `/home/vmrod/hobbies/c_programing_exercises/gdb/segfault'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000555555554611 in main () at segfaul.c:8
8		*(str+1) = 'n';

```

This is usefull sometimes when we dont want to re run the test failure


## Backtrace

A backtrace is a summary of how your program got where it is. It shows one line
per frame, for many frames, starting with the currently executing frame (frame
zero), followed by its caller (frame one), and on up the stack.

```
(gdb) bt
#0  0x0000555555554611 in main () at segfaul.c:8
(gdb) bt full
#0  0x0000555555554611 in main () at segfaul.c:8
        str = 0x5555555546a4 "GfG"
```

Even if we have nested functions:


```
#include <stdio.h>

void foo(){
	char *str;
	/* Stored in read only part of data segment */
	str = "GfG";
	/* Problem:  trying to modify read only memory */
	*(str+1) = 'n';
}

int main() {
    foo();
	return 0;
}
```

gdb backtrace is able to do the debug:

```
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/segfault

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554611 in foo () at segfaul.c:8
8		*(str+1) = 'n';
(gdb) bt
#0  0x0000555555554611 in foo () at segfaul.c:8
#1  0x0000555555554625 in main () at segfaul.c:11
```

## info registers

```
(gdb) info registers

rip            0x555555554611	0x555555554611 <foo+23>
```

As we can see the addrs: 0x555555554611 match with the one reported by
segfault:

```
0x0000555555554611 in foo () at segfaul.c:8
```

## More complete debug view

GDB provides a nice view of the code while we walk through the source:

Example code:

```
int main() {
    int count=0;
    for (int i=0;i<10;i++){
        count = count +10;
    }
	return 0;
}
```

Compile and run the debug as:

```
gcc -g loop.c -o loop
gdb ./loop -tui
```
This will present a really nice view of the code at the time we set brakpoints
and are able to print each variable:

```
b main  \\ breakpoint at main
run     \\ run the code
n       \\ next
p count \\

(gdb) p count
$3 = 10
(gdb) p count
$4 = 10
(gdb) n
(gdb) n
(gdb) n
(gdb) p count
$5 = 30
```

To clear the breakpoints:

clear:

Delete any breakpoints at the next instruction to be executed in the selected
stack frame (see section Selecting a frame). When the innermost frame is
selected, this is a good way to delete a breakpoint where your program just
stopped.

clear function
clear filename:function

Delete any breakpoints set at entry to the function function.
clear linenum
clear filename:linenum
Delete any breakpoints set at or within the code of the specified line. delete
[breakpoints] [range...]

Delete the breakpoints, watchpoints, or catchpoints of the breakpoint ranges
specified as arguments. If no argument is specified, delete all breakpoints
(GDB asks confirmation, unless you have set confirm off). You can abbreviate
this command as d.

For example:

```
(gdb) clear main
Deleted breakpoint 1
```

And we can now set a breakpoint with condition:

```
(gdb) break 5 if count=80
Breakpoint 1 at 0x60e: file loop.c, line 5.
(gdb) run
Starting program: /home/vmrod/hobbies/c_programing_exercises/gdb/loop

Breakpoint 1, main () at loop.c:5
(gdb) p count
$1 = 80

```

